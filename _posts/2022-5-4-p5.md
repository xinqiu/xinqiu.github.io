---
layout: post
title: 智能合约开发初探
tag: Program
cover_url: https://www.ledger.com/wp-content/uploads/2021/04/cover-4.png
cover_meta: >
  Photo by [ledger](https://www.ledger.com/es/academy/blockchain/what-is-a-smart-contract)
---

## 智能合约

上一篇讲了如何在本地搭建以太坊本地私链，这次就聊聊如何在自己搭建的私链上部署合约以及运行合约。本地搭建合约的好处在于，一方面可以自定义挖矿难度以及控制挖矿情况，另一方面实际上是可以对部署的合约进行断点调试，熟悉合约执行的每一步，观察存储的数据情况。

### 主流协议

由于有了[openzeppelin](https://docs.openzeppelin.com/contracts/4.x/wizard)的存在，写合约容易了很多，只需要选择好相应的协议，直接复用其实现就好，真可谓无脑发币和NFT，难怪近期的NFT项目越来越多。

#### ERC20

最为使用最广泛的token合约，仅需几行代码就可以快速发币，以下就是最基础的发币代码。

```js
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.4;

import "@openzeppelin/contracts/token/ERC20/ERC20.sol";

contract MyToken is ERC20 {
    constructor(uint256 initialSupply) ERC20("MyToken", "MTK") {
      _mint(msg.sender, initialSupply);
    }
}
```

OpenZeppelin的ERC20协议以包含了以下接口：

* totalSupply：规定了代币的总量，外部可以通过调用这个函数来获得代币总量是多少
* balanceOf：获取某地址的代币余额
* transfer：调用transfer函数将自己的token转账给_to地址，_value为转账个数
*approve：批准_spender账户从自己的账户转移_value个token。可以分多次转移
* transferFrom：用于第三方（_spender）从被授权的账户转账到目标账户
* allowance：返回_spender还能提取token的个数

属实非常贴心，看上去只需要确定名字，就可以上手。而这里的allowance概念有点意思，他是允许第三方从账上划转token，借这个功能就可以做一个swap。另外要注意的一点是，不要直接往代币合约地址直接转账(transfer)。透过合约代码也可以发现，ERC20在链上维护了一个address<->Balance的Map结构，记录了每个地址的余额情况。

#### ERC721

最近炒得很火的NFT基本上都是基于ERC721协议实现的，ERC721和ERC20不同的点在于，每一个token都是非同质的，即独一无二的，因此在链上的储存信息是不同的，ERC721记录的虽然也是维护了一个Map结构，但这里是维护token<->address的信息，记录每个token的owner。

```js
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.4;

import "@openzeppelin/contracts/token/ERC721/ERC721.sol";
import "@openzeppelin/contracts/access/Ownable.sol";

contract MyToken is ERC721, Ownable {
    constructor() ERC721("MyToken", "MTK") {}

    function safeMint(address to, uint256 tokenId) public onlyOwner {
        _safeMint(to, tokenId);
    }
}
```

最关键的部分即`mint`操作，`mint`完成了创建出一个NFT给对应的address。



### 开发工具

#### Remix

#### Truffle

#### Hardhat


### 部署合约


### 高级玩法

### ERC721A项目部署



#### ERC777本地私链部署流程

#### NBA NFT 本地部署

